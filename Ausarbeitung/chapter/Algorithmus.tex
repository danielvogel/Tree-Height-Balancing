\chapter{Algorithmus}
Der Algorithmus kann in zwei Phasen unterschieden werden.

\section{Finden von Baumkandidaten}
Die erste Phase des \ac{THB} besteht aus der Suche nach Teilbäumen, welche unter bestimmten Voraussetzungen sich als Wurzeln für die darauf folgende zweite Phase eignet.\\
Ausgangspunkt für diese Phase ist eine Sammlung aller Bäume, welche innerhalb des \ac{THB} bearbeitet werden sollen. Die in unserer Implementierung verwendete Graphenstruktur (s. Kapitel \ref{kap:graph}) eignet sich gut für das Iterieren durch alle bekannten Bäume und Unterbäume.\\
Grundvoraussetzungen an die Wurzel-Kandidaten sind das Assoziativ- und Kommutativgesetz. Die Operation in dem Teilbaum müssen kommutativ und assoziativ sein. Dies führt dazu, dass die Reihenfolge, in der die Operanden stehen, keinen Einfluss auf das Ergebnis der Operation haben. Beispiele für zulässige Operationen sind die Multiplikation und Addition.\\
Als zweites Auswahlkriterium spielt die Anzahl an Verwendungen der Teilbäume eine Rolle. Sofern ein Baum mehrfach verwendet wird, und es die mathematischen Voraussetzungen besitzt, wird es als Wurzel markiert. Bäume, die an mehreren Stellen markiert werden, sind häufig das obere Ende einer Rechnung und kommen deswegen in Frage.\\
Sofern der Baum einmal verwendet wird, der verwendende Baum jedoch eine andere Operation repräsentiert, wird er ebenfalls als Wurzel markiert. Auch in diesem Fall kann man vom oberen Ende einer Operation ausgehen.\\
Alle resultierenden Wurzeln werden in eine Warteschlange eingereiht, aufsteigend sortiert nach der Priorität der Operation (z.B.: Additionen niedriger priorisiert als Multiplikation).\\

\begin{lstlisting}[caption=Phase 1: Roots, label=list:roots]
NameQueue * roots(ListItem *forest){
	NameQueue * queue = new_queue();
	ListItem * current = forest;
	
	do{
		current->data->rank = -1;
		
		if(current->data->op->isAssociative 
		   && current->data->op->isCommutative){
			
			Uses * use = uses(forest, current->data->name);
			int isOpForeign = 1;          
			
			if(use->count == 1){
				isOpForeign = use->user[0]->op != current->data->op;
			}
			
			if(use->count > 1 || (use->count == 1 && isOpForeign)){               
				current->data->isRoot = 1;
				enqueue(queue, current->data->name,current->data->op->precedence);
			}
		}
	} while(NULL != (current = current->right));
	
	quickSort(queue);
	return queue;
}
\end{lstlisting}

Zu jedem Teilbaum wird innerhalb der ersten Phase der Rank auf -1 initialisiert. Dies wird in Phase 2 als zusätzliches Entscheidungskriterium für die  Unterscheidung zwischen Baum-Typen und deren Tiefe verwendet.

\section{Blockwiederherstellung in balancierter Form}
Zur Wiederherstellung der Blöcke werden drei Funktionen benutzt. In diesen wird der \ac{DG} weiter analysiert und in balancierter Form neu zusammengesetzt.

\subsection{Ausbalancieren}
Diese Funktion wird auf jeden Knoten ausgeführt, der als \textit{Root} markiert ist. Hierbei wird der Rang des Knotens festgelegt und anschließend werden die untergeordneten Knoten neu geordnet.\\

\begin{lstlisting}[caption=Funktion balance(), label=list:Funktion balace()]
void balance(Node *root) {
	if (root->rank >= 0)
	{
		return; // have already processed this tree
	}

	NameQueue *q = new_queue(); // First, flatten the tree
	root->rank = flatten(root->left, q) + flatten(root->right, q);

	rebuild(q, root->op); // Then, rebuild a balanced tree
}
\end{lstlisting}

Zu Anfang der Funktion wird überprüft ob der aktuelle Knoten schon bearbeitet wurde. Dies kann anhand seines Rangs festgestellt werden. Initial hat ein Knoten den Rang -1. Sobald er bearbeitet wurde, wird hier ein Rang von mindestens 0 gesetzt. Wurde der Knoten noch nicht bearbeitet, wird eine neue \textit{Priority-Queue} erstellt. Diese wird an die direkt im Anschluss jeweils für den rechten und linken Teilbaum aufgerufene Funktion \textit{flatten()} durchgereicht. In ihr wird der Name und der Rang der untergeordneten Knoten, welche nicht als \textit{Root} markiert sind, gespeichert. Der Rückgabewert der Funktion flatten() liefert den Rang. Der Rang eines als \textit{Root} markierten Knotens ist die Addition der Ränge des linken und rechten Teilbaums. Steht der Rang fest, wird der Knoten durch den Aufruf von \textit{rebuild()} neu geordnet.

\subsection{Glätten}
Diese Funktion dient dem rekursiven durchlaufen eines Knotens und seiner Teilbäume. Initial wird sie durch die Funktion \textit{balance()} aufgerufen.\\

\begin{lstlisting}[caption=Funktion flatten(), label=list:Funktion flatten()]
int flatten(Node *var, NameQueue *q) // Flatten computes a rank for var & builds the queue
{
	if (var->isConstant == TRUE) // Cannot recur further
	{
		var->rank = 0;
		enqueue(q, var->name, var->rank);
	} else {
		if (inUEVar(var) == TRUE) // Cannot recur past top of block
		{
		var->rank = 1;
		enqueue(q, var->name, var->rank);
		} else {
			if (var->isRoot == TRUE)
			{
				balance(var); // Recur to find its rank
				enqueue(q, var->name, var->rank);
			} else { // var is Tj in jth op in block
				flatten(var->left, q); // Recur on left operand
				flatten(var->right, q); // Recur on right operand
			}
		}
	}

	return var->rank;
}
\end{lstlisting}

Diese Funktion unterscheidet in vier verschiedene Fälle:
\begin{enumerate}
	\item Beim Knoten handelt es sich um eine Konstante:\\
	Der Rang wird auf 0 gesetzt und der Knoten wird der \textit{Priority-Queue} hinzugefügt.
	\item Der Knoten ist in UEVar vorhanden:\\
	In UEvar sind alle Elemente gespeichert die von einem übergeordneten Knoten kommen. Ist dies der Fall wird der Rang auf 1 gesetzt und der Knoten wird der \textit{Priority-Queue} hinzugefügt.
	\item Der Knoten ist als \textit{Root} markiert:\\
	In diesem Fall wird die Funktion \textit{balance()} mit dem aktuellen Knoten als Parameter aufgerufen. Hierdurch wird eine neue \textit{Priority-Queue} angelegt und die untergeordneten Knoten werden weiter optimiert. Anschließend wird auch dieser Knoten der bereits vorhandenen \textit{Priority-Queue} hinzugefügt.
	\item Alle anderen Fälle:\\
	Für den jeweils linken und rechten Teilbaum wird die Funktion \textit{flatten()} aufgerufen um rekursiv bis an das Ende des Baums zu gelangen.
\end{enumerate}

Wurden alle Knoten so durchlaufen kann mit Hilfe der Funktion \textit{rebuild()} der optimierte Baum aufgebaut werden.

\subsection{Baumwiederherstellung}

Bei der letzten Phase des \ac{THB}-Algorithmus handelt es sich um das Wiederherstellen der Bäume aus den vorherigen Verarbeitungsschritten.

Hierbei muss die verarbeitende Methode\footnote{Die Methode \textit{void rebuild(NameQueue *q, Operation *op)} ist im Code-Anhang unter \textit{thb/src/thb.c} zu finden.} folgende Schritte vollführen:

Als Parameter erhält die Methode eine Liste mit Namen sowie den zugehörigen Operator - wie eingangs erwähnt, muss dieser für den kompletten Teilbaum gleich sein. Es werden nun die beiden obersten Elemente aus der Liste entnommen (diese sind nach Rang sortiert, also werden immer die Elemente mit dem niedrigsten Rang entnommen) und mit diesen ein neuer Knoten erstellt.

Handelt es sich bei beiden Elementen um Variablen, werden die Knoten mit dem zugehörigen Operator gefaltet und entweder als Wurzel gesetzt (wenn die Liste leer ist) oder als neuer Knoten wieder in die Liste eingereiht.

Ist wenigstens einer der beiden Knoten keine Variable, wird zunächst erneut der Status der Liste abgefragt. Ist diese leer, ist der Algorithmus beim Wurzelknoten angekommen und der Baum, der nun an diesem Knoten hängt, kann in die Liste der Ergebnisbäume eingetragen werden.

Ist die Liste nicht leer, wird eine neue temporäre Variable für den neuen Knoten erstellt und dieser in die Liste eingereiht. Der Rang ergibt sich hierbei in jedem Fall aus der Summe der Ränge der beiden Kindknoten, die eingangs aus der Liste extrahiert wurden.

Der hier verwendete Algorithmus geht so vor, dass die innerhalb der Schleife entstehenden Teilbäume zunächst in eine Liste eingetragen werden, aus der im Anschluss mittels der Methode \textit{Tree *getTreeFromList(ListItem *list)} der fertige Baum generiert wird. Die aus jedem Aufruf der \textit{rebuild}-Methode entstandenen Bäume werden in der globalen Variable \textit{resultTrees} gespeichert.